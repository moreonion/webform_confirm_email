<?php


// FIXME
// test with email strings, not components (if that makes any sense)
// test multiple confirmations (ORed: one trigger needed to send all)
/*
 *
 * conditions could actually be infered from email config
 *
 */

/**
 * Implements hook_webform_submission_delete().
 *
 * Respond to a Webform submission being deleted - if a submission
 * is deleted the hash for the confirmation URL can be deleted too
 *
 * @param $node
 *   The Webform node on which this submission was made.
 * @param $submission
 *   The Webform submission that was just deleted from the database.
 */
function webform_confirm_email_webform_submission_delete($node, $submission) {
  db_query(
    'delete from {webform_confirm_email_code} where nid = %d and sid = %d',
    $node->nid,
    $submission->sid
  );
  db_query(
    'delete from {webform_confirm_email_conditional} '.
      'where nid = %d and sid = %d',
    $node->nid,
    $submission->sid
  );
}

function webform_confirm_email_get_email_type($nid, $eid) {

  $obj = db_fetch_object(
    db_query(
      'SELECT email_type '.
         'FROM {webform_confirm_email} ' .
           'WHERE nid = %d ' .
           'AND   eid = %d ',
      (int) $nid,
      (int) $eid
    )
  );

  return (int)($obj->email_type);
}

/**
 * generate a hash for a new email submission, or get an existing hash
 *
 * @param $nid
 *   node id of the submitted form
 * @param $sid
 *   submission id of the submitted form
 * @param $email
 *   email address of the submitter; if empty, it's assumed that the submission
 *   has already happened and the webform_confirm_email_code table is searched
 *   for a hash
 */
function webform_confirm_email_generate_key($nid, $sid, $email = null) {
  if (isset($email)) {
    return hash_hmac(
      'md5', serialize(array($nid, $sid, $email)), drupal_get_private_key()
    );
  }
  else {
    return db_result(
      db_query(
        'select code from {webform_confirm_email_code} '.
          'where nid = %d and sid = %d',
        $nid,
        $sid
      )
    );
  }
}

/**
 * Implementation of hook_mail_alter().
 * When drupal sends an email this function checks whether there is an entry
 * in the webform_confirm_email table that identifies the email as being a
 * conditional or confirmational mail.
 * If it's a confirmational mail a hash code is generated, an URL is generated
 * out of the hash and the "%confirm_url" is replaced in the email by this generated
 * confirmation URL.
 * If it's a conditional email, the email is stopped from being send; This is because
 * after a webform submission the webform module would send all emails that are
 * registered for this form; but we want the conditional email to be send only when
 * the user uses the confirmation link that is send to him/her in the confirmation email.
 *
 * @param $message
 */
function webform_confirm_email_mail_alter(&$message) {
  $email_type = webform_confirm_email_get_email_type($message['params']['email']['nid'], $message['params']['email']['eid']);
  $eid = (int) $message['params']['email']['eid'];
  $nid = (int) $message['params']['email']['nid'];
  $sid = (int) ($message['params']['submission']->sid);
  $obj = array(
    'nid' => $nid,
    'sid' => $sid,
  );

  if ($email_type == 1) {
    $obj['datetime'] = time();
    $obj['email']    = $message['to'];
    $code            = webform_confirm_email_generate_key($nid, $sid, $obj['email']);
    $obj['eid']      = $eid;
    $obj['code']     = $code;
    $confirm_url     = url(
      "node/$nid/confirm_email/$sid/$code",
      array('absolute' => true, 'external' => false)
    );
    // replace %confirm_url with proper URL
    // may have to rewrap the mail, not sure yet
    foreach ($message['body'] as $i => $b) {
      $message['body'][$i] = str_replace('%confirm_url', $confirm_url, $b);
    }
    $result = db_result(
      db_query(
        'select count(*) from {webform_confirm_email_code} '.
          'where nid = %d and sid = %d',
        $nid,
        $sid
      )
    );
    if ($result) {
      drupal_write_record(
        'webform_confirm_email_code', $obj, array('nid', 'sid')
      );
    }
    else {
      drupal_write_record('webform_confirm_email_code', $obj);
    }
  }
  elseif ($email_type == 2) {

    $obj['message'] = $message;
    // prevents drupal_mail from actually sending the message
    $message['to'] = '+';
    $message['send'] = FALSE;
    drupal_write_record('webform_confirm_email_conditional', $obj);
  }
}

/**
 * Form submit callback function of the confirmation form
 * the user gets presented when he/she clicks on the confirmation URL
 * that was sent to him/her with the confirmation email.
 * It's main purpose is to send off the conditional email that was stopped
 * in the webform_confirm_email_mail_alter function.
 */
function _webform_confirm_email_confirmed_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'node';// somewhere else.....
  $nid = (int) $form['nid']['#value'];
  $sid = (int) $form['sid']['#value'];

  db_query(
    'delete from {webform_confirm_email_code} '.
      'where nid = %d and sid = %d',
    $nid,
    $sid
  );

  $query = 'select ecid, message from {webform_confirm_email_conditional} '.
    'where nid = %d and sid = %d';

  while ($obj = db_fetch_object(db_query($query, $nid, $sid))) {
    $message = unserialize($obj->message);
    // Concatenate and wrap the e-mail body.
    if (is_array($message['body'])) {
      $message['body'] = implode("\n\n", $message['body']);
    }
    $message['body'] = drupal_wrap_mail($message['body']);
    $message['result'] = drupal_mail_send($message);
    if ($message['result']) {
      db_query(
        'delete from {webform_confirm_email_conditional} '.
        'where ecid = %d',
        $obj->ecid
      );
    } else {
      watchdog(
        'mail',
        'Error sending e-mail (from %from to %to).',
        array('%from' => $message['from'], '%to' => $message['to']),
        WATCHDOG_ERROR
      );
      drupal_set_message(
        t(
          'Unable to send e-mail. Please contact the site administrator '.
            'if the problem persists.'
        ),
        'error'
      );
    }
  }
}

/**
 * This function builds the confirmation form that a user reaches
 * when he/she followes the link provided in the confirmation email.
 * The submit callback function, that is set here, will later take
 * care of sending the conditional email.
 */
function webform_confirm_email_response_form($form_state, $nid, $sid, $code) {
  if (empty($code)) {
    return array('ha' => array(
      '#type' => 'markup',
      '#value' => 'Missing code, what are you trying to pull!?'
    ));
  }

  if (webform_confirm_email_generate_key($nid->nid, $sid->sid) !== $code) {
    return array('ha' => array(
      '#type' => 'markup',
      '#value' => t('Invalid code.')
    ));
  }

  $form = array(
    'nid' => array('#type' => 'value', '#value' => $nid->nid),
    'sid' => array('#type' => 'value','#value' => $sid->sid),
    '#submit' => array('_webform_confirm_email_confirmed_form_submit')
  );

  $question = t('Confirm your email address?');
  $description = t(
    'You are here to confirm your email address to complete a form submission '.
      'process. You can ackowledge this was you, click no to report the abuse'.
      'of your email address or ignore this form knowing no email messages '.
      'were sent from our site in your name.'
  );
  $report_abuse_url = 'node/' . $nid->nid . '/report_abuse/' . $sid->sid . "/$code";
  return confirm_form(
    $form, $question, $report_abuse_url, $description,
    t('Yes, that was me.'),
    t('No, someone is using my email address without my knowledge.')
  );
}

/**
 * Implementation of hook_menu().
 * The callback function is registered here to handle all page requests
 * with confirmation hash codes in the URL
 */
function webform_confirm_email_menu() {
  return array(
    'node/%webform_menu/confirm_email/%webform_menu_submission/%' => array(
      'title' => 'Submit email confirmation',
      'load arguments' => array(1),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('webform_confirm_email_response_form', 1, 3, 4),
      'access callback' => true,
      'type' => MENU_CALLBACK,
    ),
    //FIXME
    //We're not doing anything helpful with this right now.
    'node/%webform_menu/report_abuse/%webform_menu_submission/%' => array(
      'title' => t('Report abuse regarding email confirmation'),
      'load arguments' => array(1),
      'page callback' => 'webform_confirm_email_report_abuse',
      'page arguments' => array(1, 3, 4),
      'access callback' => true,
      'type' => MENU_CALLBACK,
    )
  );
}

/**
 * Report abuse callback function, currently not implemented
 */
function webform_confirm_email_report_abuse() {
  return t('Sorry, not implemented yet. Try <a href="/contact">contact</a>.');
  //FIXME
}

/**
 * Implements hook_webform_component_delete().
 *
 * If a webform component is being deleted we check
 * if this component is an email address field and if so
 * we delete the confirmation emails
 *
 * @param $component
 *   The Webform component being deleted.
 */
function webform_confirm_email_webform_component_delete($component) {
  $nid = (int) $component['nid'];
  $cid = (int) $component['cid'];
  if (!$nid || !$cid) {
    return;
  }

  $results = db_query(
    'SELECT eid from {webform_emails} WHERE nid = %d AND email = %d',
    $nid,
    $cid
  );
  while ($wfemail = db_fetch_object($results)) {
    if (empty($wfemail->eid)) {
      continue;
    }
    $eid = (int) $wfemail->eid;
    db_query(
      'DELETE from {webform_confirm_email} WHERE nid = %d AND eid = %d',
      $nid,
      $eid
    );
    // FIXME
    // We need to handle deletions from
    // webform_confirm_email_confirm and webform_confirm_email_code.
    // webform module should take care of the following but since it doesn't...
    db_query(
      'DELETE from {webform_emails} WHERE nid = %d AND eid = %d',
      $nid,
      $eid
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * This adds a submit handler callback for the webform settings, so when
 * webform email settings are changed (an webform email is deleted) we
 * can react on this
 */
function webform_confirm_email_form_webform_email_delete_form_alter(&$form, &$form_state) {
  $form['#submit'][] = '_webform_confirm_email_email_delete';
}

/**
 * This implements the submit handler callback for an webform
 * email delete event
 *
 * @param $form
 *   the form from which a webform email is deleted
 *
 * @param $form_state
 *   the form_state of the form
 */
function _webform_confirm_email_email_delete($form, &$form_state) {
  $nid = (int) $form['email']['#value']['nid'];
  $eid = (int) $form['email']['#value']['eid'];
  if ($nid && $eid) {
    db_query(
      'DELETE from {webform_confirm_email} WHERE nid = %d AND eid = %d',
      $nid,
      $eid
    );
    // FIXME
    // We need to handle deletions from
    // webform_confirm_email_confirm and webform_confirm_email_code.
  }
}



/**
 * Implements hook_form_FORM_ID_alter()
 *
 */
function webform_confirm_email_form_webform_emails_form_alter(&$form, &$form_state) {

  $form['emails']['add'] = $form['add'];
  unset($form['add']);
  foreach(array('option', 'custom', 'component') as $add_option) {
    $form['emails']['add']['emails_' . $add_option] = $form['emails']['add']['email_' . $add_option];
    unset($form['emails']['add']['email_' . $add_option]);
  }
  $form['emails']['add_button'] = $form['add_button'];
  unset($form['add_button']);

  $query = db_query(
    'SELECT eid, email_type '.
      'FROM {webform_confirm_email} ' .
        'WHERE nid = %d ' .
        'AND   email_type IN (1, 2)',
    (int) $form['#node']->nid
  );

  $result = array();
  while ($row = db_fetch_array($query)) {
    $result[$row['eid']] = $row['email_type'];
  }

  foreach(array(1 => 'confirmation_request', 2 => 'confirmation') as $email_type_id => $email_type_name) {

    $form[$email_type_name] = array();

    foreach($result as $eid => $email_type) {

      if ($email_type == $email_type_id) {
        $form[$email_type_name][$eid]['email']   = $form['emails'][$eid]['email'];
        $form[$email_type_name][$eid]['subject'] = $form['emails'][$eid]['subject'];
        $form[$email_type_name][$eid]['from']    = $form['emails'][$eid]['from'];

        unset($form['emails'][$eid]);

        $form[$email_type_name]['add'] = array(
          '#theme' => 'webform_email_add_form',
          '#tree'  => FALSE,
        );

        $form[$email_type_name]['add'][$email_type_name . '_option'] = array(
          '#type' => 'radios',
          '#options' => array(
            'custom'    => t('Address'),
            'component' => t('Component value'),
          ),
          '#default_value' => 'custom',
        );

        $form[$email_type_name]['add'][$email_type_name . '_custom'] = array(
          '#type'      => 'textfield',
          '#size'      => 24,
          '#maxlength' => 500,
        );

        $form[$email_type_name]['add'][$email_type_name . '_component'] = array(
          '#type'    => 'select',
          '#options' => webform_component_list($form['#node'], 'email_address', FALSE),
        );

        if (empty($form[$email_type_name]['add'][$email_type_name . '_component']['#options']) == TRUE) {
          $form[$email_type_name]['add'][$email_type_name . '_component']['#options'][''] = t('No available components');
          $form[$email_type_name]['add'][$email_type_name . '_component']['#disabled'] = TRUE;
        }

        $form[$email_type_name]['add_button'] = array(
          '#type'   => 'submit',
          '#value'  => t('Add'),
          '#weight' => 45,
        );
      }
    }
  }
}

function webform_confirm_email_theme_registry_alter(&$theme_registry) {
  $theme_registry['webform_emails_form']['function'] = 'theme_webform_confirm_emails_form';
  $theme_registry['webform_email_add_form']['function'] = 'theme_webform_confirm_email_add_form';
}

function theme_webform_confirm_emails_form($form) {
  // Add CSS to display submission info. Don't preprocess because this CSS file is used rarely.
  drupal_add_css(drupal_get_path('module', 'webform') . '/css/webform-admin.css', 'theme', 'all', FALSE);
  drupal_add_js(drupal_get_path('module', 'webform') . '/js/webform-admin.js', 'module', 'header', FALSE, TRUE, FALSE);

  $node = $form['#node'];

  $header = array(
    t('E-mail to'),
    t('Subject'),
    t('From'),
    array(
      'data'    => t('Operations'),
      'colspan' => 2
    )
  );

  $output = '';
  foreach(array(
      'emails'               => 'Standard emails (always send)',
      'confirmation_request' => 'Confirmation request emails (always send)',
      'confirmation'         => 'Confirmation emails (only send when the confirmation URL is used)') as $email_type => $title) {

    $rows = array();
    if (empty($form[$email_type]) == FALSE) {
      foreach (element_children($form[$email_type]) as $eid) {
        if ($eid != 'add' && $eid != 'add_button') {
          // Add each component to a table row.
          $rows[] = array(
            drupal_render($form[$email_type][$eid]['email']),
            drupal_render($form[$email_type][$eid]['subject']),
            drupal_render($form[$email_type][$eid]['from']),
            l(t('Edit'),   'node/' . $node->nid . '/webform/' . $email_type . '/' . $eid),
            l(t('Delete'), 'node/' . $node->nid . '/webform/' . $email_type . '/' . $eid . '/delete'),
          );
        }
      }
    }
    else {
      $rows[] = array(array('data' => t('Currently not sending e-mails, add an e-mail recipient below.'), 'colspan' => 5));
    }

    // Add a row containing form elements for a new item.
    $row_add_email = array(
      array(
        'colspan' => 3,
        'data'    => drupal_render($form[$email_type]['add'])
      ),
      array(
        'colspan' => 2,
        'data'    => drupal_render($form[$email_type]['add_button'])
      ),
    );
    $rows[] = array('data' => $row_add_email, 'class' => 'webform-add-form');

    $output .= '<h2>' . $title . '</h2>';
    $output .= theme('table', $header, $rows, array('id' => 'webform-' . $email_type));
  }

  $output .= drupal_render($form);
  return $output;
}

function theme_webform_confirm_email_add_form($form) {

  $email_type = $form['#array_parents'][0];

  // Add a default value to the custom e-mail textfield.
  $form[$email_type . '_custom']['#attributes']['rel'] = t('email@example.com');
  $form[$email_type . '_custom']['#attributes']['class'] = 'webform-set-active webform-default-value';
  $form[$email_type . '_option']['custom']['#title'] = $form[$email_type . '_option']['custom']['#title'] . ': ' . drupal_render($form[$email_type . '_custom']);

  // Render the component value.
  $form[$email_type . '_component']['#attributes']['class'] = 'webform-set-active';
  $form[$email_type . '_option']['component']['#title'] = $form[$email_type . '_option']['component']['#title'] . ': ' . drupal_render($form[$email_type . '_component']);

  // For spacing consistency, every option is wrapped in webform-container-inline.
  foreach (element_children($form[$email_type . '_option']) as $option) {
    $form[$email_type . '_option'][$option]['#prefix'] = '<div class="webform-container-inline">';
    $form[$email_type . '_option'][$option]['#suffix'] = '</div>';
  }

  return drupal_render($form);
}


/**
 * Implements hook_form_FORM_ID_alter()
 *
 * This hook adds a radio button list titled "MESSAGE TYPE" to the webform
 * "Edit e-mail settings" site
 */
function webform_confirm_email_form_webform_email_edit_form_alter(&$form, &$form_state) {
  $instructions = $form['template']['tokens']['#value'];
  $search = '<p>' . t(
    'You may use special tokens in this field that will be replaced with '.
    'dynamic values.'
  ) . '</p>';
  $confirmation_tokens = array(
    t(
      '@confirm_url - URL needed to confirm email address.',
      array('@confirm_url' => '%confirm_url')
    )
  );
  $rep = $search . theme(
    'item_list', $confirmation_tokens, t('Confirmation variables')
  );
  $form['template']['tokens']['#value'] = str_replace(
    $search, $rep, $instructions
  );
  if (isset($form['eid']['#value'])) {
    $nid = (int) $form['node']['#value']->nid;
    $eid = (int) $form['eid']['#value'];
    $result = db_query(
      'SELECT email_type from {webform_confirm_email} '.
        'WHERE nid = %d AND eid = %d',
      $nid,
      $eid
    );
    $object = db_fetch_object($result);
    $email_type = isset($object->email_type) ? (int) $object->email_type : 0;
  }
  else {
    $email_type = 0;
  }
  $form['email_type'] = array(
    '#title' => t('Message type'),
    '#type' => 'radios',
    '#default_value' => $email_type,
    '#description' => t(
      'Should this email always be sent, only after confirmation, etc.'
    ),
    '#options' => array(
      0 => t('Always'), 1 => t('Confirmation'), 2 => t('Conditional')
    ),
  );
  $form['#submit'][] = '_webform_confirm_email_component_type_form_submit';
}

/**
 * This implements the submit handler callback for an webform
 * email settings edit event
 *
 * @param $form
 *   the form for which webform email settings are changed
 *
 * @param $form_state
 *   the form_state of the form
 */
function _webform_confirm_email_component_type_form_submit($form, &$form_state) {
  if (empty($form_state['values']['email_type'])) {
    return;
  }
  $obj = array(
    'nid' => (int) $form['node']['#value']->nid,
    'email_type' => (int) $form_state['values']['email_type']
  );
  if (isset($form['eid']['#value'])) {
    $obj['eid'] = $form['eid']['#value'];
    drupal_write_record('webform_confirm_email', $obj, array('nid', 'eid'));
  }
  else {
    $obj['eid'] = db_result(
      db_query(
        'SELECT MAX(eid) FROM {webform_emails} WHERE nid = %d',
        $obj['nid']
      )
    );
    drupal_write_record('webform_confirm_email', $obj);
  }
}

